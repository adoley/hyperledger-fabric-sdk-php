<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: peer/proposal_response.proto

namespace Protos;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * ProposalResponsePayload is the payload of a proposal response.  This message
 * is the "bridge" between the client's request and the endorser's action in
 * response to that request. Concretely, for chaincodes, it contains a hashed
 * representation of the proposal (proposalHash) and a representation of the
 * chaincode state changes and events inside the extension field.
 * </pre>
 *
 * Protobuf type <code>protos.ProposalResponsePayload</code>
 */
class ProposalResponsePayload extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * Hash of the proposal that triggered this response. The hash is used to
     * link a response with its proposal, both for bookeeping purposes on an
     * asynchronous system and for security reasons (accountability,
     * non-repudiation). The hash usually covers the entire Proposal message
     * (byte-by-byte). However this implies that the hash can only be verified
     * if the entire proposal message is available when ProposalResponsePayload is
     * included in a transaction or stored in the ledger. For confidentiality
     * reasons, with chaincodes it might be undesirable to store the proposal
     * payload in the ledger.  If the type is CHAINCODE, this is handled by
     * separating the proposal's header and
     * the payload: the header is always hashed in its entirety whereas the
     * payload can either be hashed fully, or only its hash may be hashed, or
     * nothing from the payload can be hashed. The PayloadVisibility field in the
     * Header's extension controls to which extent the proposal payload is
     * "visible" in the sense that was just explained.
     * </pre>
     *
     * <code>bytes proposal_hash = 1;</code>
     */
    private $proposal_hash = '';
    /**
     * <pre>
     * Extension should be unmarshaled to a type-specific message. The type of
     * the extension in any proposal response depends on the type of the proposal
     * that the client selected when the proposal was initially sent out.  In
     * particular, this information is stored in the type field of a Header.  For
     * chaincode, it's a ChaincodeAction message
     * </pre>
     *
     * <code>bytes extension = 2;</code>
     */
    private $extension = '';

    public function __construct() {
        \GPBMetadata\Peer\ProposalResponse::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * Hash of the proposal that triggered this response. The hash is used to
     * link a response with its proposal, both for bookeeping purposes on an
     * asynchronous system and for security reasons (accountability,
     * non-repudiation). The hash usually covers the entire Proposal message
     * (byte-by-byte). However this implies that the hash can only be verified
     * if the entire proposal message is available when ProposalResponsePayload is
     * included in a transaction or stored in the ledger. For confidentiality
     * reasons, with chaincodes it might be undesirable to store the proposal
     * payload in the ledger.  If the type is CHAINCODE, this is handled by
     * separating the proposal's header and
     * the payload: the header is always hashed in its entirety whereas the
     * payload can either be hashed fully, or only its hash may be hashed, or
     * nothing from the payload can be hashed. The PayloadVisibility field in the
     * Header's extension controls to which extent the proposal payload is
     * "visible" in the sense that was just explained.
     * </pre>
     *
     * <code>bytes proposal_hash = 1;</code>
     */
    public function getProposalHash()
    {
        return $this->proposal_hash;
    }

    /**
     * <pre>
     * Hash of the proposal that triggered this response. The hash is used to
     * link a response with its proposal, both for bookeeping purposes on an
     * asynchronous system and for security reasons (accountability,
     * non-repudiation). The hash usually covers the entire Proposal message
     * (byte-by-byte). However this implies that the hash can only be verified
     * if the entire proposal message is available when ProposalResponsePayload is
     * included in a transaction or stored in the ledger. For confidentiality
     * reasons, with chaincodes it might be undesirable to store the proposal
     * payload in the ledger.  If the type is CHAINCODE, this is handled by
     * separating the proposal's header and
     * the payload: the header is always hashed in its entirety whereas the
     * payload can either be hashed fully, or only its hash may be hashed, or
     * nothing from the payload can be hashed. The PayloadVisibility field in the
     * Header's extension controls to which extent the proposal payload is
     * "visible" in the sense that was just explained.
     * </pre>
     *
     * <code>bytes proposal_hash = 1;</code>
     */
    public function setProposalHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->proposal_hash = $var;
    }

    /**
     * <pre>
     * Extension should be unmarshaled to a type-specific message. The type of
     * the extension in any proposal response depends on the type of the proposal
     * that the client selected when the proposal was initially sent out.  In
     * particular, this information is stored in the type field of a Header.  For
     * chaincode, it's a ChaincodeAction message
     * </pre>
     *
     * <code>bytes extension = 2;</code>
     */
    public function getExtension()
    {
        return $this->extension;
    }

    /**
     * <pre>
     * Extension should be unmarshaled to a type-specific message. The type of
     * the extension in any proposal response depends on the type of the proposal
     * that the client selected when the proposal was initially sent out.  In
     * particular, this information is stored in the type field of a Header.  For
     * chaincode, it's a ChaincodeAction message
     * </pre>
     *
     * <code>bytes extension = 2;</code>
     */
    public function setExtension($var)
    {
        GPBUtil::checkString($var, False);
        $this->extension = $var;
    }

}

